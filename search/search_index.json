{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Dracon!","text":"<p>Dracon is a configuration system for Python applications built on top of YAML. It aims to solve common configuration headaches by adding powerful features for modularity, dynamic value generation, type safety, and even command-line interface creation.</p> <p>Think of it as YAML++, supercharged for complex application needs.</p>"},{"location":"#why-use-dracon","title":"Why Use Dracon?","text":"<p>Plain YAML is great for simple configs, but as applications grow, you often run into challenges:</p> <ul> <li>Repetition: How do you share common settings across different parts of your config or different environments?</li> <li>Dynamic Values: How do you derive configuration values from environment variables, calculations, or other config keys?</li> <li>Environment Management: How do you manage distinct configurations for development, staging, and production without excessive duplication?</li> <li>Secrets: How do you safely include sensitive data?</li> <li>Type Safety: How do you ensure your configuration matches the types expected by your Python code?</li> <li>CLI Integration: How do you bridge the gap between config files and command-line arguments smoothly?</li> </ul> <p>Dracon addresses these by providing:</p> <ul> <li>Includes: Load and merge configuration from files, Python packages, environment variables, and even other parts of the same document.</li> <li>Interpolation: Embed Python expressions directly into your YAML to compute values dynamically.</li> <li>Merging: Define precisely how different configuration sources should be combined using flexible merge strategies.</li> <li>Pydantic Integration: Leverage Pydantic models for robust type validation and easy object construction.</li> <li>Deferred Nodes: Control when parts of your configuration are constructed, allowing for complex setup sequences.</li> <li>CLI Generation: Automatically build command-line interfaces directly from your Pydantic configuration models.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Let's see a small example.</p> <p>1. Install Dracon:</p> <pre><code>pip install dracon\n</code></pre> <p>2. Define a Pydantic Model (e.g., <code>models.py</code>):</p> <pre><code># models.py\nfrom pydantic import BaseModel\n\nclass DatabaseConfig(BaseModel):\n    host: str\n    port: int\n    username: str\n</code></pre> <p>3. Create a Configuration File (<code>config.yaml</code>):</p> <pre><code># config.yaml\napp_name: MyAwesomeApp\nlog_level: ${getenv('LOG_LEVEL', 'INFO')} # Use an env var or default\n\ndatabase: !DatabaseConfig # Tells Dracon to use your Pydantic model\n  host: localhost\n  port: 5432\n  # Include username from another file (e.g., for secrets)\n  username: !include file:db_user.yaml\n</code></pre> <p>4. Create <code>db_user.yaml</code>:</p> <pre><code># db_user.yaml\nadmin\n</code></pre> <p>5. Load the Configuration (<code>main.py</code>):</p> <pre><code># main.py\nfrom dracon import DraconLoader\nfrom models import DatabaseConfig # Import your model\n\n# Provide the model class in the context so Dracon can find it\nloader = DraconLoader(context={'DatabaseConfig': DatabaseConfig})\n\n# Load the main config file\nconfig = loader.load('config.yaml')\n\n# Access values - note that config.database is now a DatabaseConfig instance!\nprint(f\"App Name: {config.app_name}\")\nprint(f\"Log Level: {config.log_level}\")\nprint(f\"Database Host: {config.database.host}\")\nprint(f\"Database Port: {config.database.port}\")\nprint(f\"Database User: {config.database.username}\")\n\nassert isinstance(config.database, DatabaseConfig)\n</code></pre> <p>6. Run it:</p> <pre><code>python main.py\n</code></pre> <p>This simple example demonstrates environment variable access (<code>${getenv(...)</code>), file inclusion (<code>!include</code>), and automatic Pydantic model construction (<code>!DatabaseConfig</code>).</p>"},{"location":"#the-dracon-lifecycle-how-it-works","title":"The Dracon Lifecycle: How it Works","text":"<p>Understanding how Dracon processes your configuration is key. It happens in several stages:</p> <ol> <li>Input: Dracon starts with your root YAML file(s), initial context, and potentially CLI arguments.</li> <li>Composition Phase: This is where Dracon's magic happens before creating Python objects.<ul> <li>YAML Parsing: Reads the YAML structure using <code>ruamel.yaml</code>.</li> <li>Include Resolution: Processes <code>!include</code> tags (and <code>*anchor</code> copies), fetching and inserting content from files, packages, environment variables, anchors, etc. This is recursive.</li> <li>Instruction Processing: Executes directives like <code>!define</code>, <code>!if</code>, <code>!each</code> which modify the YAML node structure itself (e.g., adding context, removing nodes, generating multiple nodes).</li> <li>Merge Resolution: Processes <code>&lt;&lt;:</code> merge keys, combining different YAML structures according to specified rules.</li> <li>(Internal Steps): Prepares nodes for interpolation, handles deferred node wrapping.</li> </ul> </li> <li>Construction Phase: Dracon builds the final Python objects from the composed YAML node tree.<ul> <li>Uses type tags (<code>!TypeName</code>) to determine the target Python class.</li> <li>Leverages Pydantic for validation and construction if a model is specified.</li> <li>Creates <code>LazyInterpolable</code> wrappers for <code>${...}</code> expressions.</li> <li>Creates <code>Resolvable</code> wrappers if specified.</li> <li>Builds standard Python dicts/lists or Dracon's <code>Mapping</code>/<code>Sequence</code> containers.</li> </ul> </li> <li>Runtime Phase: Your Python code interacts with the loaded configuration object.<ul> <li>Accessing values triggers lazy evaluation of <code>${...}</code> expressions.</li> <li>Calling <code>.construct()</code> on <code>DeferredNode</code> objects triggers their delayed composition and construction.</li> <li>Calling <code>.resolve()</code> on <code>Resolvable</code> objects triggers their final processing.</li> </ul> </li> </ol> <p>This multi-stage process allows Dracon to handle complex dependencies and dynamic configurations effectively.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Dive deeper into the core features:</p> <ul> <li>Loading Configuration</li> <li>Includes (Modularity)</li> <li>Interpolation (Dynamic Values)</li> <li>Merging Configurations</li> <li>Instructions (Composition Logic)</li> <li>Working with Types</li> </ul>"},{"location":"cli/","title":"Command-Line Interfaces","text":"<p>Dracon allows you to automatically generate command-line interfaces (CLIs) directly from your Pydantic configuration models. You can define your application's parameters and configuration structure in one place (the Pydantic model) and get a type-safe, well-documented CLI with integrated configuration file loading and overrides.</p>"},{"location":"cli/#basic-usage","title":"Basic Usage","text":"<ol> <li>Define Your Configuration Model: Use a Pydantic <code>BaseModel</code>.</li> <li>(Optional) Annotate Fields: Use <code>typing.Annotated</code> and <code>dracon.Arg</code> to customize CLI arguments (help text, short names, etc.).</li> <li>Create the Program: Use <code>dracon.make_program()</code>.</li> <li>Parse Arguments: Call <code>program.parse_args()</code>.</li> </ol> <pre><code># main.py\nimport sys\nfrom pydantic import BaseModel\nfrom typing import Annotated\nfrom dracon import DraconLoader, make_program, Arg # Import necessary parts\n\n# 1. Define the model\nclass CliConfig(BaseModel):\n    input_file: Annotated[str, Arg(\n        positional=True, # Make this a positional argument\n        help=\"Path to the input data file.\"\n    )]\n    output_dir: Annotated[str, Arg(\n        short='o', # Add a short flag -o\n        help=\"Directory to save results.\"\n    )]\n    threshold: Annotated[float, Arg(help=\"Processing threshold.\")] = 0.5 # Add default\n    verbose: Annotated[bool, Arg(short='v', help=\"Enable verbose output.\")] = False\n\n    # Example application logic method\n    def run(self):\n        print(f\"Running with config:\")\n        print(f\"  Input: {self.input_file}\")\n        print(f\"  Output Dir: {self.output_dir}\")\n        print(f\"  Threshold: {self.threshold}\")\n        print(f\"  Verbose: {self.verbose}\")\n        # ... your actual logic here ...\n\n# 3. Create the program instance\nprogram = make_program(\n    CliConfig,\n    name=\"my-data-processor\", # Optional: Program name for help message\n    description=\"Processes data files based on configuration.\" # Optional help description\n)\n\nif __name__ == \"__main__\":\n    try:\n        # 4. Parse arguments\n        # Returns the populated Pydantic model instance and the raw args dict\n        config_model, raw_args = program.parse_args(sys.argv[1:])\n\n        # 5. Use the populated and validated model\n        config_model.run()\n\n    except Exception as e: # Catch potential parsing/validation errors\n        print(f\"Error: {e}\", file=sys.stderr)\n        # Consider calling program.print_help() here or letting it exit\n        sys.exit(1)\n</code></pre>"},{"location":"cli/#running-the-cli","title":"Running the CLI","text":"<p>The generated CLI supports several features automatically:</p> <ul> <li>Help Message: <pre><code>$ python main.py --help\n# Output: (Formatted help message based on model and Arg annotations)\n# Usage: my-data-processor [OPTIONS] INPUT_FILE\n#\n# Arguments:\n#   INPUT_FILE    Path to the input data file.\n#                 type: STR\n#                 REQUIRED\n# ... etc ...\n</code></pre></li> <li>Positional Arguments: <pre><code>$ python main.py path/to/data.csv --output-dir results/\n# input_file='path/to/data.csv', output_dir='results/', threshold=0.5, verbose=false\n</code></pre></li> <li>Optional Arguments (Long/Short):</li> </ul> <pre><code>$ python main.py data.csv -o out/ --threshold 0.8 -v\n# input_file='data.csv', output_dir='out/', threshold=0.8, verbose=true\n</code></pre> <p>!!! note   Option names are automatically derived from field names (e.g., <code>output_dir</code> -&gt; <code>--output-dir</code>). Use <code>Arg(long='custom-name')</code> to override.</p> <ul> <li>Boolean Flags: Fields typed as <code>bool</code> become flags. Simply including the flag sets it to <code>True</code>.   <pre><code>$ python main.py data.csv -o out # verbose is false (default)\n$ python main.py data.csv -o out -v # verbose is true\n</code></pre></li> </ul>"},{"location":"cli/#customizing-arguments-with-arg","title":"Customizing Arguments with <code>Arg</code>","text":"<p>The <code>dracon.Arg</code> class, used within <code>Annotated</code>, provides fine-grained control:</p> <pre><code>from typing import Annotated\nfrom dracon import Arg\n\nclass AdvancedConfig(BaseModel):\n    config_file: Annotated[str, Arg(\n        long='config', # Custom long name (--config instead of --config-file)\n        short='c',\n        help='Path to primary configuration YAML file.'\n    )]\n    threads: Annotated[int, Arg(\n        help='Number of processing threads (0 for auto).',\n        default=1 # Override Pydantic default for CLI help if needed\n    )]\n    input_path: Annotated[str, Arg(\n        positional=True, # A positional argument\n        help='Input data source.'\n    )]\n    force_update: Annotated[bool, Arg(\n        short='f',\n        help='Force update even if output exists.'\n    )]\n    log_setup_level: Annotated[str, Arg(\n        # Execute this function when the arg is parsed\n        action=setup_logging_action, # Define this function elsewhere\n        help='Set logging level (DEBUG, INFO, etc).'\n    )]\n    output_path: Annotated[Resolvable[str], Arg(\n        # Mark as resolvable for post-processing\n        resolvable=True,\n        help='Output file path (can be derived).'\n    )]\n    metadata_file: Annotated[str, Arg(\n         # Automatically treat value as 'file:...' for Dracon includes/loading\n        is_file=True,\n        help='Path to metadata YAML file.'\n    )]\n</code></pre> <ul> <li><code>short</code>: Single character for the short flag (e.g., <code>'c'</code> for <code>-c</code>).</li> <li><code>long</code>: Custom long flag name (e.g., <code>'config'</code> for <code>--config</code>).</li> <li><code>help</code>: Description shown in <code>--help</code>.</li> <li><code>positional</code>: If <code>True</code>, the argument is positional instead of an option flag. Order is determined by field definition order in the model.</li> <li><code>action</code>: A function <code>func(program: Program, value: Any)</code> called immediately after the argument value is parsed. Useful for side effects like setting up logging.</li> <li><code>resolvable</code>: If <code>True</code>, the argument's value will be wrapped in a <code>Resolvable</code> object, delaying its final processing (see Resolvable Values).</li> <li><code>is_file</code>: If <code>True</code>, instructs Dracon internally that this argument represents a file path, potentially influencing how it's handled if used within Dracon's loading/include mechanisms activated by CLI arguments.</li> <li><code>default</code>: Can be used to specify a default value specifically for the CLI help message, potentially overriding the Pydantic model default for display purposes.</li> </ul>"},{"location":"cli/#integration-with-dracon-configuration-loading","title":"Integration with Dracon Configuration Loading","text":"<p>This is where the CLI module truly integrates with the rest of Dracon:</p> <ol> <li> <p>Loading Config Files (<code>+</code> prefix): Arguments starting with <code>+</code> are treated as configuration files to be loaded and merged before applying CLI overrides.</p> <pre><code># Load base config, then production overrides, then apply CLI args\n$ python main.py +base.yaml +prod.yaml path/to/data.csv --threshold 0.9\n</code></pre> <p>Files are merged sequentially using Dracon's default merge strategy (<code>{~&lt;}[~&lt;]</code> - roughly, replace keys/lists, new wins).</p> </li> <li> <p>CLI Overrides (<code>--key value</code>): Standard option arguments directly override values coming from defaults or loaded config files. Nested keys are supported using dot notation.</p> <pre><code># Assume config.yaml defines database.host = 'localhost'\n$ python main.py +config.yaml data.csv --database.host db.prod.svc --database.port 5433\n</code></pre> </li> <li> <p>Defining Context Variables (<code>--define.</code>): You can set context variables for Dracon's interpolation engine directly from the CLI.     <pre><code># Define context variables ENV and BATCH_SIZE\n$ python main.py data.csv --define.ENV=production --define.BATCH_SIZE=100\n</code></pre>     These variables (<code>ENV</code>, <code>BATCH_SIZE</code>) become available within <code>${...}</code> expressions in your loaded YAML files.</p> </li> </ol>"},{"location":"cli/#order-of-precedence","title":"Order of Precedence","text":"<p>Dracon applies configuration sources in the following order (later sources override earlier ones):</p> <ol> <li>Pydantic Model Defaults.</li> <li>First <code>+config1.yaml</code> loaded.</li> <li>Second <code>+config2.yaml</code> loaded (merged onto result of #2).</li> <li>... subsequent <code>+configN.yaml</code> files.</li> <li>Context variables from <code>--define.VAR=value</code>.</li> <li>CLI argument overrides (<code>--key value</code>).</li> </ol> <p>Dracon's merging, includes, and interpolation rules are applied throughout this process.</p>"},{"location":"cli/#putting-it-together","title":"Putting It Together","text":"<p>The <code>commandline</code> module provides a seamless way to build robust, type-safe CLIs that fully integrate with Dracon's powerful configuration loading capabilities, allowing users to configure your application through a combination of defaults, files, environment variables (via YAML), and command-line arguments.</p>"},{"location":"deferred/","title":"Advanced: Deferred Nodes","text":"<p>Sometimes, you need more control over when a part of your configuration is fully processed and constructed into a Python object. Deferred nodes allow you to pause the composition and construction process for a specific node until you explicitly trigger it later in your code.</p>"},{"location":"deferred/#why-use-deferred-nodes","title":"Why Use Deferred Nodes?","text":"<ul> <li>Late-Binding Context: You need to provide context (variables, functions) that is only available after the main configuration has been loaded (e.g., secrets loaded from a vault, runtime parameters).</li> <li>Conditional Construction: You want to decide whether or how to construct a component based on other parts of the loaded configuration.</li> <li>Performance: Avoid constructing complex or resource-intensive objects until they are actually needed.</li> <li>Manual Orchestration: Explicitly control the order of object initialization when dependencies exist.</li> </ul>"},{"location":"deferred/#syntax","title":"Syntax","text":"<ol> <li> <p><code>!deferred</code> Tag: Apply the tag directly to the node you want to defer.</p> <pre><code>database_connection: !deferred # Defer construction of this mapping\n  host: db.example.com\n  port: 5432\n  password: ${DB_PASSWORD} # Needs DB_PASSWORD in context later\n</code></pre> </li> <li> <p><code>!deferred:TypeName</code> Tag: Defer construction and specify the target type.</p> <pre><code># Defer construction, expecting a DatabaseConfig object eventually\ndatabase: !deferred:DatabaseConfig\n  host: db.example.com\n  port: 5432\n  password: ${DB_PASSWORD}\n</code></pre> </li> <li> <p><code>!deferred::clear_ctx=var1,var2</code> Tag: Defer construction and specify context variables that should be ignored from the parent scope when this node is eventually constructed. This isolates the deferred node's context.</p> <pre><code>!define ENV: production\n\ncomponent: !deferred::clear_ctx=ENV # Don't inherit ENV\n  !define ENV: development # Use a local ENV for this component\n  setting: ${ENV} # Will resolve to 'development'\n</code></pre> </li> <li> <p><code>DraconLoader(deferred_paths=...)</code>: Force nodes matching specific KeyPaths to be deferred, even without an explicit tag.     <pre><code># Force anything under 'services.*.database' to be deferred\nloader = DraconLoader(deferred_paths=['/services/*/database'])\nconfig = loader.load('config.yaml')\n# config.services.web.database will be a DeferredNode\n</code></pre></p> </li> </ol>"},{"location":"deferred/#the-deferrednode-object","title":"The <code>DeferredNode</code> Object","text":"<p>When Dracon encounters a node marked for deferral, it doesn't construct it immediately. Instead, it creates a <code>dracon.deferred.DeferredNode</code> object. This object acts as a placeholder and contains:</p> <ul> <li>The original YAML node structure.</li> <li>A snapshot of the context available at that point in the composition.</li> <li>A reference to the <code>DraconLoader</code> instance used.</li> <li>The full <code>CompositionResult</code> at the time of deferral.</li> </ul> <p>This captured state allows the construction process to be resumed later accurately.</p> <pre><code>from dracon import DraconLoader\nfrom dracon.deferred import DeferredNode\n\nloader = DraconLoader()\nyaml_content = '''\napi_client: !deferred\n    base_url: \"https://api.example.com\"\n    api_key: ${API_KEY}\n'''\nconfig = loader.loads(yaml_content)\n\n# config.api_client is NOT the final dict/object yet\nassert isinstance(config.api_client, DeferredNode)\nprint(config.api_client)\n# Output: DeferredNode(...)\n</code></pre>"},{"location":"deferred/#manual-construction-construct","title":"Manual Construction: <code>.construct()</code>","text":"<p>To get the actual Python object, you call the <code>.construct()</code> method on the <code>DeferredNode</code> instance.</p> <pre><code># ... (previous example continued)\n\n# Provide the missing context variable when constructing\nruntime_context = {'API_KEY': 'my-secret-key-123'}\nfinal_api_client = config.api_client.construct(context=runtime_context)\n\n# Now final_api_client is the constructed object (likely a dict or custom class)\nprint(final_api_client)\n# Output might be: {'base_url': 'https://api.example.com', 'api_key': 'my-secret-key-123'}\n\n# You can optionally replace the deferred node in your config object\nconfig.api_client = final_api_client\n</code></pre>"},{"location":"deferred/#selective-deferral-within-construct","title":"Selective Deferral within <code>.construct()</code>","text":"<p>You can even defer sub-parts within the manually constructed node using the <code>deferred_paths</code> argument in <code>.construct()</code>. Paths are relative to the deferred node itself.</p> <pre><code>complex_service: !deferred\n  database:\n    host: db\n    credentials: ${DB_CREDS} # Needs late binding\n  cache:\n    host: cache\n    credentials: ${CACHE_CREDS} # Needs late binding\n\n# --- Python ---\ndeferred_node = config.complex_service\n\n# Construct the service, but keep 'database' and 'cache' deferred\npartially_constructed = deferred_node.construct(\n    deferred_paths=['/database', '/cache'] # Paths relative to complex_service\n)\n\nassert isinstance(partially_constructed.database, DeferredNode)\nassert isinstance(partially_constructed.cache, DeferredNode)\n\n# Later, construct the database part\ndb_creds = get_database_credentials()\nfinal_db = partially_constructed.database.construct(context={'DB_CREDS': db_creds})\n\n# And the cache part\ncache_creds = get_cache_credentials()\nfinal_cache = partially_constructed.cache.construct(context={'CACHE_CREDS': cache_creds})\n</code></pre>"},{"location":"deferred/#context-handling","title":"Context Handling","text":"<ul> <li>A <code>DeferredNode</code> captures the context present when it was created during the initial load.</li> <li>Context provided via <code>.construct(context=...)</code> is merged with the captured context. By default, the provided runtime context takes priority (<code>{&lt;~}</code>).</li> <li>Variables specified in <code>!deferred::clear_ctx=...</code> are removed from the captured context before merging, preventing inheritance from the parent scope.</li> </ul>"},{"location":"deferred/#pickling-and-parallelism","title":"Pickling and Parallelism","text":"<p><code>DeferredNode</code> objects (along with the <code>DraconLoader</code> and <code>CompositionResult</code> they reference) are designed to be picklable (using Python's <code>pickle</code> or <code>dill</code>).</p> <p>This allows you to:</p> <ol> <li>Load a configuration containing deferred nodes.</li> <li>Send these <code>DeferredNode</code> objects to different processes or machines (e.g., using <code>multiprocessing</code>).</li> <li>Provide process-specific context and call <code>.construct()</code> in parallel to build different components independently.</li> </ol> <pre><code>import multiprocessing\nimport pickle\nfrom dracon import DraconLoader\nfrom dracon.deferred import DeferredNode\n\n# --- config.yaml ---\n# workers:\n#   - !deferred::clear_ctx=WORKER_ID\n#     id: ${WORKER_ID}\n#     config:\n#       param: ${WORKER_ID * 10}\n#   - !deferred::clear_ctx=WORKER_ID\n#     id: ${WORKER_ID}\n#     config:\n#       param: ${WORKER_ID * 10}\n\ndef process_worker(pickled_deferred_node_data):\n    worker_id, pickled_node = pickled_deferred_node_data\n    # Unpickle the node in the new process\n    deferred_node = pickle.loads(pickled_node)\n    # Construct with process-specific context\n    worker_config = deferred_node.construct(context={'WORKER_ID': worker_id})\n    print(f\"Worker {worker_id} constructed: {worker_config}\")\n    return worker_config\n\nif __name__ == \"__main__\":\n    loader = DraconLoader()\n    config = loader.load('config.yaml')\n\n    deferred_workers = config.workers\n    pickled_workers = []\n    for i, node in enumerate(deferred_workers):\n        assert isinstance(node, DeferredNode)\n        pickled_workers.append((i, pickle.dumps(node))) # Pass ID and pickled node\n\n    with multiprocessing.Pool(processes=len(pickled_workers)) as pool:\n        results = pool.map(process_worker, pickled_workers)\n\n    print(\"All workers processed.\")\n</code></pre>"},{"location":"includes/","title":"Includes (Modularity)","text":"<p>As configurations grow, keeping everything in one file becomes unwieldy. Dracon's <code>!include</code> system lets you split your configuration into logical, reusable parts and compose them together. You can include YAML files from the filesystem or embedded in Python packages, and even include environment variables or other nodes defined in the document.</p>"},{"location":"includes/#basic-syntax-include","title":"Basic Syntax: <code>!include</code>","text":"<p>The primary way to include content is using the <code>!include</code> tag followed by a source identifier string.</p> <pre><code># Include content from settings.yaml in the same directory\napp_settings: !include file:$DIR/settings.yaml # $DIR holds the current file's directory. see [Automatic Context Variables](#automatic-context-variables)\n\n# Include default config from an installed Python package\ndefaults: !include pkg:my_package:path/to/configs/defaults.yaml\n\n# Include an API key directly from an environment variable\napi_key: !include env:MY_API_KEY\n\ncommon_config: &amp;common\n  timeout: 30\n  retries: 3\n\n# Include a block defined by an anchor in THIS document\nservice_a:\n  &lt;&lt;: !include common # Include using anchor name\n  endpoint: /a\n</code></pre>"},{"location":"includes/#include-sources","title":"Include Sources","text":"<p>Dracon supports several source types for <code>!include</code>:</p> <ol> <li> <p>Loaders (<code>loader:path</code>):</p> <ul> <li><code>file:path/to/file.yaml</code>: Loads from the filesystem. Relative paths are resolved based on the including file's directory.</li> <li><code>pkg:package_name:path/to/resource.yaml</code>: Loads from resources within an installed Python package.</li> <li><code>env:VARIABLE_NAME</code>: Directly includes the string value of an environment variable.</li> <li><code>custom_loader:identifier</code>: Uses a custom loader function registered with <code>DraconLoader</code>.</li> </ul> </li> <li> <p>Anchors (<code>anchor_name</code>):</p> <ul> <li>If the source string matches an anchor (<code>&amp;anchor_name</code>) defined earlier in the current effective document (including previous includes), Dracon includes a deep copy of the anchored node structure.</li> </ul> <pre><code>base_params: \u00b6ms\n  rate: 0.5\n  limit: 100\n\nfeature1:\n  # Gets a copy of the base_params dictionary\n  params: !include params\n  specific: value1\n</code></pre> <p>Copy vs. Reference (<code>*anchor</code>)</p> <p>Standard YAML uses <code>*anchor_name</code> (aliases) to create references to the same object instance. Dracon intercepts <code>*anchor_name</code> syntax during composition and treats it like <code>!include anchor_name</code>, performing a deep copy of the node structure. This is useful for templating but differs from standard YAML behavior regarding object identity, especially for mutable types like lists and dicts. If you need object identity, use value references (<code>${@/path}</code>).</p> </li> <li> <p>Context Variables (<code>$variable_name</code>):</p> <ul> <li>If the source string starts with <code>$</code> and matches a key in the current node's context, Dracon includes the value associated with that variable. The value is typically expected to be a node or something Dracon can represent as a node.</li> </ul> <pre><code>!define template_node: &amp;tpl\n  setting: default\n\nconfig:\n  # Includes the node referenced by the 'template_node' variable\n  instance1: !include $template_node\n</code></pre> </li> </ol>"},{"location":"includes/#targeting-sub-keys-sourcepathtokey","title":"Targeting Sub-keys (<code>source@path.to.key</code>)","text":"<p>You can include just a specific part of a source document by appending <code>@</code> followed by a KeyPath to the key you want to extract.</p> <pre><code># settings.yaml\ndatabase:\n  host: db.example.com\n  port: 5432\n  pool:\n    size: 10\nlogging:\n  level: INFO\n</code></pre> <pre><code># main.yaml\n# Include only the database host\ndb_host: !include file:settings.yaml@database.host # Result: \"db.example.com\"\n\n# Include the entire database section\ndatabase_config: !include file:settings.yaml@database\n\n# Include the pool size\npool_size: !include file:settings.yaml@database.pool.size # Result: 10\n</code></pre> <p>Note</p> <p>Keys containing literal dots (<code>.</code>) within the source document need to be escaped with a backslash (<code>\\.</code>) in the KeyPath target. E.g., <code>source@section\\.with\\.dots</code>.</p>"},{"location":"includes/#interpolation-in-include-paths","title":"Interpolation in Include Paths","text":"<p>Include paths themselves can contain Interpolation expressions, allowing for dynamic includes based on context.</p> <pre><code>!define ENV: ${getenv('DEPLOY_ENV', 'dev')}\n\n# Include environment-specific settings\nenv_settings: !include file:./config/settings_${ENV}.yaml\n\n# Include version-specific config from a package\nversioned_api: !include pkg:my_api:v${API_VERSION}/config.yaml\n</code></pre>"},{"location":"includes/#automatic-context-variables","title":"Automatic Context Variables","text":"<p>When using <code>file:</code> or <code>pkg:</code> loaders, Dracon automatically adds variables to the context of the included file's nodes, which are useful for relative path resolution:</p> <ul> <li><code>$DIR</code>: The directory containing the included file.</li> <li><code>$FILE</code>: The full path to the included file.</li> <li><code>$FILE_STEM</code>: The filename without the extension.</li> <li><code>$FILE_EXT</code>: The file extension (including the dot).</li> <li><code>$FILE_LOAD_TIME</code>: Timestamp (YYYY-MM-DD HH:MM:SS).</li> <li><code>$FILE_LOAD_TIME_UNIX</code>: Unix timestamp (seconds).</li> <li><code>$FILE_LOAD_TIME_UNIX_MS</code>: Unix timestamp (milliseconds).</li> <li><code>$FILE_SIZE</code>: File size in bytes.</li> <li><code>$PACKAGE_NAME</code>: (For <code>pkg:</code> loader only) The name of the package.</li> </ul> <pre><code># Example: inside includes/component.yaml\ntemplate_dir: ${$DIR}/templates # Path relative to this file\nlog_file: /var/log/${$FILE_STEM}.log # Log file named after this file\n</code></pre>"},{"location":"includes/#best-practices","title":"Best Practices","text":"<ul> <li>Organize: Group related settings (database, logging, features) into separate files.</li> <li>Layer: Create a <code>base.yaml</code> and environment-specific files (<code>dev.yaml</code>, <code>prod.yaml</code>) that include and merge the base.</li> <li>Secrets: Keep sensitive data in separate, appropriately permissioned files and include them.</li> <li>Relative Paths: Use <code>$DIR</code> for includes within the same component/directory structure to make configurations more portable.</li> </ul>"},{"location":"instructions/","title":"Instructions (Composition Logic)","text":"<p>Beyond includes and merges, Dracon provides special <code>!instruction</code> tags that allow you to embed logic directly into your YAML to control how the configuration structure is assembled during the composition phase. These instructions operate on the YAML node tree before final Python objects are constructed.</p>"},{"location":"instructions/#defining-variables-define-and-set_default","title":"Defining Variables: <code>!define</code> and <code>!set_default</code>","text":"<p>These instructions let you create variables within the configuration's context, which can then be used in subsequent Interpolation expressions (<code>${...}</code> or <code>$(...)</code>).</p> <ul> <li> <p><code>!define var_name: node_value</code></p> </li> <li> <p>Assigns the constructed value of <code>node_value</code> to <code>var_name</code> in the context of the current node and its children.</p> </li> <li>If <code>node_value</code> contains an interpolation expression (<code>${...}</code> or <code>$(...)</code>), it is evaluated at composition time.</li> <li>The <code>!define var_name: ...</code> entry itself is removed from the final configuration mapping.</li> <li> <p>Overwrites any existing variable with the same name in the current context scope.</p> </li> <li> <p><code>!set_default var_name: node_value</code></p> </li> <li>Similar to <code>!define</code>, but only sets <code>var_name</code> if it doesn't already exist in the current context scope.</li> <li>Useful for providing default values that can be overridden by earlier includes or parent contexts.</li> <li>Also removed from the final configuration mapping.</li> </ul> <pre><code># --- Example ---\n!define app_version: \"1.2.0\"\n!define is_prod: ${getenv('ENV') == 'production'} # Evaluated now\n!set_default log_level: \"INFO\" # Set only if not already defined\n\nconfig:\n  version: ${app_version} # Uses \"1.2.0\"\n  debug_mode: ${not is_prod} # Uses calculated boolean\n  logging:\n    level: ${log_level} # Uses \"INFO\" unless overridden earlier\n\n# The final 'config' object will NOT contain keys like '!define app_version'.\n# It will only have 'version', 'debug_mode', and 'logging'.\n</code></pre>"},{"location":"instructions/#conditional-composition-if","title":"Conditional Composition: <code>!if</code>","text":"<p>Conditionally includes or excludes configuration blocks based on an expression evaluated at composition time.</p> <ul> <li>Syntax: <code>!if condition_expr: node_value</code></li> <li>Behavior:</li> <li><code>condition_expr</code> is evaluated. It can be a boolean, an integer, a string evaluating to true/false, or an interpolation expression (<code>${...}</code> or <code>$(...)</code>) that resolves to a truthy/falsy value at composition time.</li> <li>If the condition is truthy:<ul> <li>If <code>node_value</code> is a mapping, its key-value pairs are merged into the parent mapping.</li> <li>If <code>node_value</code> is a scalar or sequence, the entire <code>!if condition_expr: node_value</code> entry is replaced by <code>node_value</code> (this typically only makes sense if the parent is a sequence).</li> </ul> </li> <li>If the condition is falsy, the entire <code>!if condition_expr: node_value</code> entry is removed.</li> </ul> <pre><code>!define enable_feature_x: ${getenv('FEATURE_X_ENABLED', 'false') == 'true'}\n!define env: \"prod\"\n\nsettings:\n  base: true\n  # This block is only included if enable_feature_x is true\n  !if ${enable_feature_x}:\n    feature_x_url: \"http://feature-x.svc\"\n    feature_x_retries: 5\n\n  # This block is included because env == \"prod\"\n  !if ${env == \"prod\"}:\n    monitoring_level: full\n    sampling_rate: 0.1\n\n  # This block is removed because env != \"dev\"\n  !if ${env == \"dev\"}:\n    debug_endpoint: \"/_debug\"\n</code></pre>"},{"location":"instructions/#iterative-composition-each","title":"Iterative Composition: <code>!each</code>","text":"<p>Generates multiple configuration nodes by iterating over a list or other iterable evaluated at composition time.</p> <ul> <li>Syntax: <code>!each(loop_var) iterable_expr: node_template</code></li> <li>Behavior:</li> <li><code>iterable_expr</code> (often an interpolation like <code>${range(3)}</code> or <code>${list_variable}</code>) is evaluated at composition time to produce an iterable.</li> <li>For each <code>item</code> in the iterable:<ul> <li>A temporary context is created where <code>loop_var</code> is set to the current <code>item</code>.</li> <li>A deep copy of <code>node_template</code> is made.</li> <li>The context <code>{loop_var: item}</code> is merged into the copied node's context.</li> <li>If <code>node_template</code> is a sequence (<code>- value</code>), the processed copy is appended to the resulting list.</li> <li>If <code>node_template</code> is a mapping (<code>key: value</code>), the processed key-value pairs are added to the resulting dictionary. Keys within the mapping template must often be interpolations themselves (e.g., <code>key_${loop_var}: ...</code>) to ensure uniqueness.</li> </ul> </li> <li>The original <code>!each...</code> entry is replaced by the generated list or dictionary.</li> </ul> <pre><code>!define user_list: [\"alice\", \"bob\"]\n\nconfig:\n  # Generate a list of user objects\n  users:\n    !each(name) ${user_list}:\n      - user_id: ${name.upper()} # Use loop_var 'name'\n        home_dir: \"/home/${name}\"\n        enabled: true\n\n  # Generate a dictionary of service ports\n  ports:\n    !each(i) ${range(2)}:\n      # Keys must be unique, often use interpolation\n      service_${i}: ${9000 + i}\n      # Value can also use loop_var\n      service_${i}_admin: ${9000 + i + 100}\n</code></pre> <pre><code># Resulting structure after !each processing (before final construction):\nconfig:\n  users:\n    - user_id: ALICE\n      home_dir: \"/home/alice\"\n      enabled: true\n    - user_id: BOB\n      home_dir: \"/home/bob\"\n      enabled: true\n  ports:\n    service_0: 9000\n    service_0_admin: 9100\n    service_1: 9001\n    service_1_admin: 9101\n</code></pre>"},{"location":"instructions/#excluding-nodes-noconstruct-and-__dracon__","title":"Excluding Nodes: <code>!noconstruct</code> and <code>__dracon__</code>","text":"<p>Sometimes you need helper nodes or templates during composition that shouldn't appear in the final constructed configuration object.</p> <ul> <li> <p><code>!noconstruct node</code></p> </li> <li> <p>Applies to any node (scalar, sequence, mapping).</p> </li> <li> <p>The node exists during composition and can be referenced (e.g., by <code>!define</code>, <code>!include</code>, or <code>&amp;</code> references), but it and its children are completely removed before the final construction phase begins.</p> </li> <li> <p><code>__dracon__key: ...</code></p> </li> <li>Applies only to top-level keys in a mapping.</li> <li>Any key starting with <code>__dracon__</code> (e.g., <code>__dracon__templates:</code>) behaves exactly as if it had <code>!noconstruct</code> applied to its value.</li> <li>This provides a convenient namespace for composition-only helpers without needing the <code>!noconstruct</code> tag everywhere.</li> </ul> <pre><code># Define a template but hide it from the final output\n!noconstruct &amp;service_defaults:\n  timeout: 60\n  protocol: https\n\n# Alternative using __dracon__ namespace\n__dracon__templates:\n  db_defaults: &amp;db_defaults\n    pool_size: 10\n    encoding: utf8\n\n# Use the templates\nhttp_service:\n  &lt;&lt;: *service_defaults # Include the copy\n  protocol: http # Override\n\ndatabase:\n  &lt;&lt;: *db_defaults # Include the copy\n</code></pre> <pre><code># Final constructed config:\n# {\n#   \"http_service\": {\"timeout\": 60, \"protocol\": \"http\"},\n#   \"database\": {\"pool_size\": 10, \"encoding\": \"utf8\"}\n# }\n# The '!noconstruct' node and '__dracon__templates' are gone.\n</code></pre>"},{"location":"interpolation/","title":"Interpolation (Dynamic Values)","text":"<p>Interpolation allows you to embed dynamic Python expressions directly within your YAML configuration strings. This makes your configurations more flexible and adaptable to different environments or runtime conditions.</p> <p>Dracon supports two main types of interpolation:</p>"},{"location":"interpolation/#1-lazy-interpolation","title":"1. Lazy Interpolation: <code>${...}</code>","text":"<p>This is the primary and most common form. Dracon uses the asteval library to evaluate the expressions. It provides a safe and controlled environment for evaluating Python expressions, allowing you to use standard Python syntax and functions. You can also explicitely chose to use the much more dangerous raw <code>eval</code> function, but this is obviously not recommended.</p> <ul> <li>Syntax: <code>${python_expression}</code></li> <li>Evaluation: Deferred (Lazy). The expression is not evaluated immediately when the YAML is parsed. Instead, Dracon creates a special <code>LazyInterpolable</code> object. The actual Python expression is evaluated only when the corresponding configuration value is first accessed in your Python code after loading.</li> <li>Use Cases: Calculating values based on other config keys, environment variables, or context provided at runtime. This is ideal for most dynamic configuration needs.</li> </ul> <pre><code>!define base_port: 8000\n!define instance_num: ${getenv('INSTANCE_NUM', 0)} # Evaluated later\n\nserver:\n  # Simple arithmetic, uses context vars evaluated lazily\n  port: ${base_port + instance_num}\n  # String formatting\n  host: \"server-${instance_num}.example.com\"\n  # Conditional logic\n  log_level: ${'DEBUG' if getenv('ENV') == 'dev' else 'INFO'}\n\ndatabase:\n  # Referencing another final configuration value using @\n  url: \"postgresql://${user}:${password}@${@/server.host}:${@server.port}/main_db\"\n  pool_size: ${max(4, instance_num * 2)} # Using built-in functions\n</code></pre>"},{"location":"interpolation/#referencing-other-values","title":"Referencing Other Values (<code>@</code>)","text":"<p>Inside a <code>${...}</code> expression, you can reference the final, constructed value of another key using the <code>@</code> symbol followed by a KeyPath.</p> <ul> <li>Absolute Path: <code>${@/path/from/root}</code> starts from the configuration root.</li> <li>Relative Path: <code>${@.sibling_key}</code>, <code>${@../parent_key}</code>, <code>${@../sibling/key}</code> navigate relative to the current value's location.</li> </ul> <pre><code>app:\n  name: \"MyService\"\n  port: 9000\n\nlogging:\n  # Absolute path reference\n  filename: \"/var/log/${@/app.name}.log\" # -&gt; /var/log/MyService.log\n  # Relative path reference\n  level_info: \"Log level for ${@.filename}\" # -&gt; Log level for /var/log/MyService.log\n\nsubcomponent:\n  value: 10\n  # Relative path going up\n  reference: \"App port is ${@../app.port}\" # -&gt; App port is 9000\n</code></pre> <p>Note</p> <p><code>@</code> references point to the value after all composition (includes, merges) and construction (including Pydantic validation) for that target key are complete. The evaluation is still lazy, triggered when the referencing value is accessed.</p>"},{"location":"interpolation/#referencing-nodes","title":"Referencing Nodes (<code>&amp;</code>)","text":"<p>Inside a <code>${...}</code> expression, you can also reference the raw node object itself from before construction using <code>&amp;</code> followed by an anchor name or a path.</p> <ul> <li>Syntax: <code>${&amp;anchor_name}</code>, <code>${&amp;/path/to/node}</code>, <code>${&amp;relative/path}</code>.</li> <li>Behavior: This gives the expression access to the YAML node object (e.g., a <code>DraconMappingNode</code>) as it exists during the composition phase, potentially modified by includes or merges but before it's converted into a final Python object.</li> <li>Use Cases: This is primarily useful for templating. You can use it inside list comprehensions or function calls to create multiple copies or variations of a base node structure before they get constructed.</li> </ul> <pre><code># Template node (often hidden using !noconstruct or __dracon__)\n__dracon__:\n  service_template: &amp;service_tpl\n    protocol: http\n    port: ${port_num} # port_num needs to be in context for this node\n    retries: 3\n\n# Generate multiple service configurations from the template\nservices:\n  # Uses a list comprehension with the node reference (&amp;)\n  # For each i, it creates a copy of the node referenced by &amp;service_tpl,\n  # providing 'port_num' in its context.\n  ${[&amp;service_tpl:port_num=8080+i for i in range(3)]}\n  # Resulting structure before final construction:\n  # - !mapping # Copy 1 with port_num=8080 in context\n  #   protocol: http\n  #   port: ${port_num}\n  #   retries: 3\n  # - !mapping # Copy 2 with port_num=8081 in context\n  #   protocol: http\n  #   port: ${port_num}\n  #   retries: 3\n  # - !mapping # Copy 3 with port_num=8082 in context\n  #   protocol: http\n  #   port: ${port_num}\n  #   retries: 3\n</code></pre> <p><code>&amp;</code> vs <code>@</code> Summary</p> <p>_ Use <code>${@path}</code> to get the final constructed value of another key (most common). _ Use <code>${&amp;node_ref}</code> (inside expressions) to work with the node object before construction, primarily for templating/duplication during composition. Evaluating just <code>${&amp;node_ref}</code> typically gives you a deep copy of the node's value representation at evaluation time.</p>"},{"location":"interpolation/#2-immediate-interpolation","title":"2. Immediate Interpolation: <code>$(...)</code>","text":"<p>This form is less common and serves specific purposes.</p> <ul> <li>Syntax: <code>$(python_expression)</code></li> <li>Evaluation: Immediate. The expression is evaluated during the initial YAML parsing and composition phase. The result of the expression replaces the <code>$(...)</code> token before Dracon proceeds with parsing that part of the structure.</li> <li>Use Cases:</li> <li>Dynamically generating YAML tags: <code>!$(type_name_var)</code></li> <li>Calculating simple scalar values needed immediately during parsing.</li> <li>Limitations:</li> <li>Cannot use <code>@</code> or <code>&amp;</code> references (the target nodes/values don't reliably exist yet).</li> <li>Can only access context variables that are already defined statically before this point in the parsing process. Cannot reliably access values defined using <code>${...}</code>.</li> </ul> <pre><code>!define type_name: \"str\"\n!define scale: 10\n\nconfig:\n  # Tag is determined immediately based on type_name variable\n  value: !$(type_name) 123.45 # Node gets tag !str\n\n  # Value calculated immediately\n  scaled_value: $(scale * 5.5) # Node gets value 55.0\n</code></pre>"},{"location":"interpolation/#context-availability","title":"Context Availability","text":"<p>Expressions within both <code>${...}</code> and <code>$(...)</code> can access:</p> <ul> <li>Variables provided in the <code>DraconLoader(context=...)</code>.</li> <li>Standard Python built-ins.</li> <li>Variables defined using <code>!define</code> or <code>!set_default</code> in the current or parent scope before the expression is encountered (more reliable for <code>$(...)</code>).</li> <li>Special loader context variables like <code>${$DIR}</code>, <code>${$FILE}</code> (only available within included files).</li> </ul>"},{"location":"interpolation/#how-lazy-evaluation-works-dracontainer","title":"How Lazy Evaluation Works (<code>Dracontainer</code>)","text":"<p>When you load a configuration with <code>${...}</code> expressions, Dracon typically constructs mappings and sequences using its internal <code>dracon.dracontainer.Mapping</code> and <code>dracon.dracontainer.Sequence</code> types. These containers override attribute access (<code>__getattr__</code>, <code>__getitem__</code>) to automatically trigger the resolution of <code>LazyInterpolable</code> objects the first time they are accessed. If you configure <code>DraconLoader</code> to use standard <code>dict</code> and <code>list</code>, this automatic resolution doesn't happen, and you might need to manually trigger resolution if needed (e.g., by iterating through the structure or using helper functions not explicitly provided by Dracon itself, like <code>resolve_all_lazy</code>).</p>"},{"location":"keypaths/","title":"Advanced: KeyPaths","text":"<p>Internally, Dracon uses a dot-separated <code>KeyPath</code> system to reference specific locations within a configuration structure during its composition and interpolation phases. Understanding KeyPaths helps clarify how features like <code>@</code> references, merge targets (<code>@target</code>), and <code>deferred_paths</code> work.</p>"},{"location":"keypaths/#what-is-a-keypath","title":"What is a KeyPath?","text":"<p>A <code>KeyPath</code> represents a navigation path from a root (either the absolute document root or a relative starting point) to a specific node or value within the nested configuration structure.</p>"},{"location":"keypaths/#syntax","title":"Syntax","text":"<p>KeyPaths use a dot (<code>.</code>) separated notation similar to Python attribute access, with special characters for root and parent navigation:</p> <ul> <li>Segment Separator (<code>.</code>): Separates keys in a mapping or indices in a sequence.</li> <li>Example: <code>database.host</code>, <code>users.0.name</code></li> <li>Absolute Root (<code>/</code>): When present at the beginning, indicates the path starts from the absolute root of the configuration document being processed.</li> <li>Example: <code>/app/name</code>, <code>/services/0/port</code></li> <li>Parent (<code>..</code>): Navigates one level up in the hierarchy. Can be chained (<code>...</code> for two levels up, etc.).</li> <li>Example: <code>database.connection_pool..timeout</code> (accesses <code>timeout</code> sibling of <code>connection_pool</code>)</li> <li>Escaping (<code>\\.</code> and <code>\\/</code>): If a key name itself contains a literal dot or slash, it must be escaped with a backslash in the KeyPath.</li> <li>Example: <code>config\\.with\\.dots.value</code>, <code>path\\/segment.key</code></li> <li>Wildcards (for matching only):</li> <li><code>*</code>: Matches any single segment name/index.</li> <li><code>**</code>: Matches zero or more segments.</li> <li>Used primarily in <code>deferred_paths</code> for pattern matching. <code>a.*.c</code> matches <code>a.b.c</code>, <code>a.x.c</code>. <code>a.**.d</code> matches <code>a.d</code>, <code>a.b.d</code>, <code>a.b.c.d</code>.</li> </ul> <p>Note</p> <p>The forward slash (<code>/</code>) is only used to indicate the absolute root at the beginning of a path. It is not used as a segment separator like in file paths. <code>a/b</code> is invalid; use <code>a.b</code>. A path like <code>a.b/c.d</code> is interpreted as <code>/c.d</code>.</p>"},{"location":"keypaths/#how-keypaths-are-used","title":"How KeyPaths are Used","text":"<ol> <li> <p>Value References (<code>@</code> in <code>${...}</code>):</p> <ul> <li><code>${@/path.from.root}</code>: Uses an absolute KeyPath.</li> <li><code>${@.sibling_key}</code> or <code>${@../parent.key}</code>: Uses a relative KeyPath, resolved from the location of the interpolation expression.</li> <li>Dracon calculates the target KeyPath and retrieves the final constructed value from that location.</li> </ul> </li> <li> <p>Merge Targets (<code>&lt;&lt;...@target_path:</code>):</p> <ul> <li>The <code>target_path</code> after the <code>@</code> is parsed as a KeyPath relative to the mapping containing the merge key.</li> <li>Dracon applies the merge operation at the node identified by this KeyPath.</li> </ul> </li> <li> <p>Deferred Paths (<code>DraconLoader(deferred_paths=...)</code>):</p> <ul> <li>The strings in the <code>deferred_paths</code> list are treated as KeyPath patterns (supporting <code>*</code> and <code>**</code>).</li> <li>Any node whose absolute KeyPath matches one of these patterns during composition will be wrapped in a <code>DeferredNode</code>.</li> </ul> </li> <li> <p>Include Sub-key Targeting (<code>!include source@target_path</code>):</p> <ul> <li>The <code>target_path</code> after the <code>@</code> is parsed as a KeyPath.</li> <li>Dracon first loads the entire <code>source</code>, then extracts only the node structure located at <code>target_path</code> within that source.</li> </ul> </li> </ol>"},{"location":"keypaths/#internal-representation","title":"Internal Representation","text":"<p>While you typically interact with KeyPaths as strings, Dracon internally parses them into a list of segments and special tokens (like <code>ROOT</code>, <code>UP</code>). It also performs simplification (e.g., <code>a.b..c</code> simplifies to <code>a.c</code>) before using them for lookups.</p>"},{"location":"loading/","title":"Loading Configuration","text":"<p>The primary way to interact with Dracon is through the <code>DraconLoader</code>. This class handles parsing YAML, processing Dracon's special syntax, and constructing your final Python configuration object. Dracon also provides a <code>load</code> function for convenience, which is a shortcut to create a <code>DraconLoader</code> instance and load a configuration file in one step.</p>"},{"location":"loading/#basic-usage","title":"Basic Usage","text":"<pre><code>from dracon import load\n\nconfig = load(\"path/to/your/config.yaml\")\n\n# Load from a string\nyaml_string = '''\nkey: value\nnested:\n  level: 1\n'''\nconfig_from_string = loads(yaml_string)\n\nprint(config.some_key)\nprint(config_from_string.nested.level)\n</code></pre>"},{"location":"loading/#providing-context","title":"Providing Context","text":"<p>Often, you'll need to provide runtime information or helper functions to your configuration files. This is done using the <code>context</code> argument. The context is a dictionary available during both the composition and interpolation phases.</p> <pre><code># main.py\nimport os\nfrom dracon import DraconLoader\n\ndef generate_id(prefix):\n    import uuid\n    return f\"{prefix}-{uuid.uuid4()}\"\n\ncontext = {\n    'ENV': os.getenv('ENVIRONMENT', 'development'),\n    'INSTANCE_ID': 42,\n    'generate_id': generate_id # Make function available\n}\n\nloader = DraconLoader(context=context)\nconfig = loader.load(\"app_config.yaml\")\n\nprint(config.service_id)\n</code></pre> <pre><code># app_config.yaml\nenvironment: ${ENV}\nserver_port: ${8000 + INSTANCE_ID}\nservice_id: ${generate_id(ENV)} # Call the function from context\n</code></pre>"},{"location":"loading/#default-context","title":"Default Context","text":"<p>Dracon automatically adds a few useful items to the context:</p> <ul> <li><code>getenv</code>: Equivalent to <code>os.getenv</code>.</li> <li><code>getcwd</code>: Equivalent to <code>os.getcwd</code>.</li> <li><code>construct</code>: A function to manually trigger construction of nodes (useful within <code>${...}</code>).</li> </ul>"},{"location":"loading/#loading-from-different-sources","title":"Loading from Different Sources","text":"<p>While <code>loader.load(\"path/to/file.yaml\")</code> implicitly uses the <code>file:</code> loader, you can be explicit using loader prefixes within include directives (see Includes).</p> <p>Dracon comes with built-in loaders:</p> <ul> <li><code>file:</code>: Loads from the filesystem relative to the current file or working directory.   <pre><code>settings: !include file:./settings.yaml\ncredentials: *file:/etc/secrets.conf # Absolute path\n</code></pre></li> <li><code>pkg:</code>: Loads from installed Python package resources. Requires <code>package_name:path/to/resource.yaml</code>.   <pre><code>defaults: !include pkg:my_package:configs/defaults.yaml\nbase_settings: *pkg:common_lib:base.yaml\n</code></pre></li> <li><code>env:</code>: Loads a value directly from an environment variable.   <pre><code>api_key: !include env:API_KEY\nsecret: *env:APP_SECRET\n</code></pre>   !!! note   Using <code>!include env:VAR</code> fetches the variable during the composition phase. Using <code>${getenv('VAR')}</code> fetches it during interpolation (runtime/lazy evaluation).</li> </ul>"},{"location":"loading/#custom-loaders","title":"Custom Loaders","text":"<p>You can extend Dracon to load configurations from other sources (databases, APIs, etc.) by providing custom loader functions.</p> <pre><code>import redis\nfrom dracon import DraconLoader\n\ndef load_from_redis(path: str):\n    # path is the string after 'redis:'\n    r = redis.Redis(decode_responses=True)\n    key = path\n    value = r.get(key)\n    if value is None:\n        raise FileNotFoundError(f\"Redis key '{key}' not found.\")\n    # Custom loaders should return the raw content (string)\n    # and optionally a dictionary of context variables to add.\n    return value, {'$REDIS_KEY': key}\n\n# Register the custom loader\nloader = DraconLoader(custom_loaders={'redis': load_from_redis})\n\n# Now you can use it in YAML\n# config: !include redis:my_app:settings\n</code></pre>"},{"location":"loading/#error-handling","title":"Error Handling","text":"<ul> <li>FileNotFoundError: Raised if an included file (via <code>file:</code> or <code>pkg:</code>) cannot be found.</li> <li>ValueError: Raised for invalid syntax (e.g., unknown loader, malformed include string).</li> <li>InterpolationError: Raised during <code>${...}</code> evaluation if an expression is invalid or references are broken.</li> <li>ValidationError (Pydantic): Raised if the final constructed object fails Pydantic model validation.</li> </ul>"},{"location":"loading/#caching","title":"Caching","text":"<p>By default (<code>use_cache=True</code>), Dracon caches the raw content fetched by <code>file:</code> and <code>pkg:</code> loaders to speed up loading of frequently included files. Set <code>use_cache=False</code> to disable this.</p>"},{"location":"loading/#output-types","title":"Output Types","text":"<p>By default, Dracon constructs mappings into <code>dracon.dracontainer.Mapping</code> and sequences into <code>dracon.dracontainer.Sequence</code>. These custom types handle lazy interpolation resolution automatically.</p> <p>You can instruct the loader to use standard Python <code>dict</code> and <code>list</code> instead:</p> <pre><code>from dracon import DraconLoader\n\n# Use standard Python dicts and lists\nloader = DraconLoader(base_dict_type=dict, base_list_type=list)\nconfig = loader.load(\"config.yaml\")\n\nassert isinstance(config, dict)\n# Note: With standard types, lazy interpolation needs manual triggering\n# if not accessed directly. See Interpolation documentation.\n</code></pre>"},{"location":"merging/","title":"Merging Configurations","text":"<p>Dracon extends YAML's basic merge key (<code>&lt;&lt;:</code>) with a powerful syntax to precisely control how dictionaries and lists are combined when merging configuration sources. This is essential for layering configurations, such as applying environment-specific overrides to a base configuration.</p>"},{"location":"merging/#the-merge-syntax","title":"The Merge Syntax","text":"<p>Dracon's extended merge key follows this pattern:</p> <p><code>&lt;&lt;{dict_opts}[list_opts]@target_path: merge_source</code></p> <ul> <li><code>&lt;&lt;:</code>: The standard YAML merge key indicator.</li> <li><code>{dict_opts}</code>: (Optional) Controls how dictionaries are merged.</li> <li><code>[list_opts]</code>: (Optional) Controls how lists are merged.</li> <li><code>@target_path</code>: (Optional) A KeyPath specifying a sub-key within the current mapping where the merge should be applied. If omitted, the merge applies directly to the current mapping.</li> <li><code>merge_source</code>: The node providing the data to be merged in. This is often an alias (<code>*anchor</code>) or an <code>!include</code> directive, but can also be an inline mapping or sequence.</li> </ul>"},{"location":"merging/#dictionary-merging-options-dict_opts","title":"Dictionary Merging Options (<code>{dict_opts}</code>)","text":"<p>These options control behavior when merging two dictionaries (mappings).</p> <ul> <li>Mode:</li> <li><code>+</code> (Append/Recurse - Default): Adds new keys from <code>merge_source</code>. For existing keys, if both values are dictionaries, it merges them recursively. If values are not both dictionaries (or are lists), the conflict is resolved by priority.</li> <li><code>~</code> (Replace): Adds new keys from <code>merge_source</code>. For existing keys, the value is always determined by the priority setting, completely replacing the other value (no recursion).</li> <li>Priority:</li> <li><code>&gt;</code> (Existing Wins - Default for <code>+</code>): If a key exists in both, the value from the existing dictionary (the one containing the <code>&lt;&lt;:</code> key) is kept.</li> <li><code>&lt;</code> (New Wins - Default for <code>~</code>): If a key exists in both, the value from the <code>merge_source</code> dictionary is kept.</li> <li>Depth (<code>N</code>):</li> <li><code>+N</code> (e.g., <code>{+2&gt;}</code>): Limits recursive merging (<code>+</code> mode) to <code>N</code> levels deep. Beyond this depth, conflicts are resolved by priority without further recursion.</li> </ul> <p>Examples:</p> <pre><code>base: &amp;base\n  x: 1\n  y:\n    a: 10\n  z: 100\n  list1: [a, b]\n\n# Example 1: Default-like (Append keys, Existing wins, No dict recursion unless forced)\nmerged1:\n  &lt;&lt;: *base\n  x: 2 # base.x (1) wins because existing wins by default\n  y:\n    b: 20 # Added, y is replaced because base dict merge isn't recursive by default\n  w: 300 # Added\n\n# Result merged1: { x: 1, y: { b: 20 }, z: 100, w: 300, list1: [a, b] }\n\n# Example 2: Recursive Append, New wins\nmerged2:\n  &lt;&lt;{+&lt;}: *base # Recursively merge dicts, new values win\n  x: 2 # New x (2) wins\n  y:\n    b: 20 # Added to existing y\n  w: 300 # Added\n\n# Result merged2: { x: 2, y: { a: 10, b: 20 }, z: 100, w: 300, list1: [a, b] }\n\n# Example 3: Replace, Existing wins\nmerged3:\n  &lt;&lt;{~&gt;}: *base # Replace conflicting, existing wins\n  x: 2 # Existing x (1) wins\n  y:\n    b: 20 # Existing y ({a: 10}) wins entirely, {b: 20} is ignored\n  w: 300 # Added\n\n# Result merged3: { x: 1, y: { a: 10 }, z: 100, w: 300, list1: [a, b] }\n</code></pre>"},{"location":"merging/#list-merging-options-list_opts","title":"List Merging Options (<code>[list_opts]</code>)","text":"<p>These options control behavior when a key exists in both dictionaries being merged, and both values are lists.</p> <ul> <li>Mode:</li> <li><code>~</code> (Replace - Default): The entire list is replaced by either the existing list or the new list, based on priority.</li> <li><code>+</code> (Concatenate): The lists are combined into one.</li> <li>Priority:</li> <li><code>&lt;</code> (New Wins/Prepends - Default):<ul> <li>In <code>~</code> (Replace) mode: The new list from <code>merge_source</code> is kept.</li> <li>In <code>+</code> (Concatenate) mode: The new list elements come before the existing elements (<code>new + existing</code>).</li> </ul> </li> <li><code>&gt;</code> (Existing Wins/Appends):<ul> <li>In <code>~</code> (Replace) mode: The existing list is kept.</li> <li>In <code>+</code> (Concatenate) mode: The existing list elements come before the new elements (<code>existing + new</code>).</li> </ul> </li> <li>Depth (<code>N</code>):</li> <li><code>+N</code> (e.g., <code>[+2&lt;]</code>): If lists contain nested structures, limits recursive merging within those structures to <code>N</code> levels when concatenating. (Less common).</li> </ul> <p>Examples:</p> <pre><code>base: &amp;base\n  items: [a, b]\n  config:\n    ports: [80, 443]\n\n# Example 1: Replace list, New wins (Default list behavior)\nmerged_list1:\n  &lt;&lt;: *base # Implicitly uses [~&lt;]\n  items: [c, d]\n\n# Result merged_list1: { items: [c, d], config: { ports: [80, 443] } }\n\n# Example 2: Concatenate, Existing first (Append new)\nmerged_list2:\n  &lt;&lt;[+&gt;]: *base # Concatenate, existing items first\n  items: [c, d]\n\n# Result merged_list2: { items: [a, b, c, d], config: { ports: [80, 443] } }\n\n# Example 3: Concatenate, New first (Prepend new)\nmerged_list3:\n  &lt;&lt;[+&lt;]: *base # Concatenate, new items first\n  items: [c, d]\n# Result merged_list3: { items: [c, d, a, b], config: { ports: [80, 443] } }\n</code></pre>"},{"location":"merging/#targeting-sub-keys-target_path","title":"Targeting Sub-keys (<code>@target_path</code>)","text":"<p>Apply the merge operation specifically to a nested key within the current mapping.</p> <pre><code>base: &amp;base\n  host: base_host\n  port: 1000\n\nconfig:\n  service_a:\n    host: service_a_host\n    port: 8001\n  common:\n    timeout: 30\n    # Merge *base into the 'common' sub-dictionary\n    # Using recursive append, new values win for dictionaries\n    &lt;&lt;{+&lt;}@common: *base # Result: common: { timeout: 30, host: base_host, port: 1000 }\n\n# Result config:\n# { service_a: { host: service_a_host, port: 8001 },\n#   common: { timeout: 30, host: base_host, port: 1000 } }\n</code></pre>"},{"location":"merging/#combining-options","title":"Combining Options","text":"<p>You can specify both dictionary and list options together.</p> <pre><code>defaults: &amp;defaults\n  settings:\n    retries: 3\n    active: false\n  users: [\"admin\"]\n\nproduction:\n  # For dicts: Recursive Append, New wins\n  # For lists: Concatenate, Existing first (Append new)\n  &lt;&lt;{+&lt;}[+&gt;]: *defaults\n  settings:\n    active: true # Overrides default\n    threads: 4 # Added\n  users: [\"ops\", \"dev\"] # Appended to defaults\n\n# Result production:\n# { settings: { retries: 3, active: true, threads: 4 },\n#   users: ['admin', 'ops', 'dev'] }\n</code></pre>"},{"location":"merging/#standard-yaml-merge-anchor","title":"Standard YAML Merge (<code>&lt;&lt;: *anchor</code>)","text":"<p>Dracon still respects the standard YAML merge key <code>&lt;&lt;: *anchor</code> if no specific Dracon options (<code>{}</code>, <code>[]</code>, <code>@</code>) are provided on that specific key. However, the standard YAML merge has semantics roughly equivalent to Dracon's <code>{~&lt;}</code> (Replace keys, New value wins). If you need finer control or different behavior (like recursion), use Dracon's explicit syntax.</p>"},{"location":"resolvable/","title":"Advanced: Resolvable Values","text":"<p>While Deferred Nodes pause the construction of an entire configuration branch, <code>Resolvable[T]</code> provides a way to defer the final processing or validation of a single value after the initial configuration object has been loaded.</p> <p>It's less about delaying construction and more about having a placeholder that requires an explicit <code>.resolve()</code> call to get its final form, often after other application setup or command-line argument parsing is complete.</p>"},{"location":"resolvable/#why-use-resolvable","title":"Why Use Resolvable?","text":"<ul> <li>CLI Argument Post-Processing: An argument might need validation or transformation based on other arguments or loaded configuration values that aren't available during the initial <code>parse_args</code>.</li> <li>Inter-dependent Fields: A field's final value might depend on another field that itself might be complex or deferred.</li> <li>User-Provided Hooks: Allow users to configure values that need a final check or modification step within the application logic.</li> </ul>"},{"location":"resolvable/#syntax-and-usage","title":"Syntax and Usage","text":"<ol> <li> <p>Type Hint: Use <code>Resolvable[YourType]</code> in your Pydantic model.</p> <pre><code>from pydantic import BaseModel\nfrom dracon import Resolvable\n\nclass AppConfig(BaseModel):\n    input_file: str\n    # output_file depends on input_file, mark as Resolvable\n    output_file: Resolvable[str]\n    threshold: float\n</code></pre> </li> <li> <p>YAML Tag: You can also use the <code>!Resolvable</code> or <code>!Resolvable[YourType]</code> tag in YAML, though using the type hint is more common, especially with the CLI.     <pre><code>config:\n    value: !Resolvable[int] \"10\" # Value is initially string \"10\"\n</code></pre></p> </li> </ol>"},{"location":"resolvable/#the-resolvable-object","title":"The <code>Resolvable</code> Object","text":"<p>When Dracon loads a field marked as <code>Resolvable[T]</code> (either by type hint or tag), it creates a <code>dracon.resolvable.Resolvable</code> object instead of immediately trying to create an object of type <code>T</code>. This <code>Resolvable</code> object stores:</p> <ul> <li>The underlying YAML node representing the value.</li> <li>A reference to the constructor (<code>Draconstructor</code>) used.</li> <li>The expected inner type (<code>T</code>).</li> </ul> <pre><code># Example using the AppConfig above\nloader = DraconLoader(context={'AppConfig': AppConfig})\nconfig = loader.load(\"config.yaml\") # Assume output_file is defined\n\nassert isinstance(config.output_file, Resolvable)\nprint(config.output_file.node) # Shows the YAML node for output_file\n</code></pre>"},{"location":"resolvable/#manual-resolution-resolve","title":"Manual Resolution: <code>.resolve()</code>","text":"<p>To get the final value of type <code>T</code>, you call the <code>.resolve()</code> method on the <code>Resolvable</code> instance. This triggers the Dracon constructor to process the stored node, applying any necessary context and attempting to construct an object of the inner type <code>T</code>.</p> <pre><code># ... continued\nfrom dracon import DraconLoader, Resolvable, Arg, make_program # CLI parts\nimport sys\n\nclass AppConfig(BaseModel):\n    input_file: Annotated[str, Arg(positional=True)]\n    # Mark output_file as resolvable in the CLI Arg\n    output_file: Annotated[Resolvable[str], Arg(resolvable=True)]\n    # This field is NOT resolvable\n    threshold: float = 0.5\n\nprogram = make_program(AppConfig)\nconfig, _ = program.parse_args(sys.argv[1:])\n\n# config.output_file is still a Resolvable object here\nassert isinstance(config.output_file, Resolvable)\n\n# --- Application Logic ---\n# Maybe determine the actual output path based on input\nif config.output_file.empty(): # Check if a value was provided\n    derived_output_path = config.input_file + \".out\"\n    # We can't just assign the string, we need to resolve the underlying\n    # structure (even if simple) via the constructor\n    # A bit verbose for simple strings, but necessary for consistency\n    final_output_file = config.output_file.resolve(\n        context={'derived_path': derived_output_path} # Hypothetical context\n    )\n    # Or, more simply for just overriding the value if empty:\n    final_output_file = derived_output_path # Direct assignment after check\nelse:\n    # Resolve the value provided by the user/config\n    final_output_file = config.output_file.resolve()\n\nprint(f\"Input: {config.input_file}\")\nprint(f\"Output: {final_output_file}\") # Now it's a string\nprint(f\"Threshold: {config.threshold}\")\n\nassert isinstance(final_output_file, str)\n</code></pre>"},{"location":"resolvable/#resolvable-vs-deferrednode","title":"<code>Resolvable</code> vs. <code>DeferredNode</code>","text":"<p>While both delay processing, they serve different purposes:</p> Feature <code>Resolvable[T]</code> <code>DeferredNode</code> Granularity Single value / field Entire node branch Purpose Delay final validation/processing Delay composition &amp; construction Trigger Manual call to <code>.resolve()</code> Manual call to <code>.construct()</code> Input Typically loaded value/node Captures node &amp; context state Output Aims for type <code>T</code> Constructs object based on node/tag Use Case CLI post-processing, inter-field deps Late context binding, resource mgmt. <p>Use <code>Resolvable</code> when you have the configuration structure loaded but need a final application-level step to finalize a specific value. Use <code>DeferredNode</code> when you need to postpone the entire construction of a component until later, often because necessary context is missing during the initial load.</p>"},{"location":"types/","title":"Working with Types","text":"<p>Dracon leverages YAML tags (<code>!TypeName</code>) and integrates closely with Pydantic to provide type validation and construct specific Python objects from your configuration.</p>"},{"location":"types/#specifying-types-with-tags","title":"Specifying Types with Tags","text":"<p>You can tell Dracon what kind of Python object to create from a YAML node by prefixing it with a tag.</p> <pre><code># Standard YAML tags for built-in types\ncount: !int \"10\" # Constructed as Python int 10\npi: !float \"3.14159\" # Constructed as Python float 3.14159\nmessage: !str 123 # Constructed as Python str \"123\"\nenabled: !bool \"true\" # Constructed as Python bool True\n\n# Tag for a custom or Pydantic type\ndatabase: !DatabaseConfig # Dracon will look for DatabaseConfig\n  host: localhost\n  port: 5432\n</code></pre>"},{"location":"types/#type-resolution","title":"Type Resolution","text":"<p>When Dracon encounters a tag like <code>!DatabaseConfig</code> or <code>!my.package.utils.HelperClass</code>, it tries to find the corresponding Python class (<code>DatabaseConfig</code> or <code>HelperClass</code>) using the following search order:</p> <ol> <li>DraconLoader Context: Checks the <code>context</code> dictionary passed during <code>DraconLoader</code> initialization. This is the primary way to make your custom classes known.     <pre><code>from my_models import DatabaseConfig, CacheConfig\nloader = DraconLoader(context={\n    'DatabaseConfig': DatabaseConfig,\n    'CacheConfig': CacheConfig\n})\n</code></pre></li> <li>Default Known Types: Checks built-in Dracon types like <code>Resolvable</code>.</li> <li>Standard Modules: Looks in common modules like <code>typing</code>, <code>pydantic</code>.</li> <li>Package/Module Import: If the tag includes a package path (<code>!my.package.MyClass</code>), Dracon attempts to import <code>my.package</code> and find <code>MyClass</code> within it.</li> <li>Fallback Resolution: Uses internal Python mechanisms (<code>typing._eval_type</code>) as a last resort.</li> </ol> <p>Tip</p> <p>Always prefer adding your custom types to the <code>DraconLoader</code> context for reliable resolution.</p>"},{"location":"types/#pydantic-integration","title":"Pydantic Integration","text":"<p>Dracon's integration with Pydantic is seamless and powerful:</p> <ol> <li>Tag Matching: If the resolved type for a tag (e.g., <code>!DatabaseConfig</code>) is a Pydantic <code>BaseModel</code>, Dracon uses it.</li> <li>Data Construction: Dracon first constructs the YAML node into a basic Python type (usually a <code>dict</code> for mappings).</li> <li>Pydantic Validation: It then passes this dictionary to Pydantic's validation machinery (<code>TypeAdapter(YourModel).validate_python(data)</code>).</li> <li>Result: You get a fully validated Pydantic model instance. All of Pydantic's features work, including type coercion, default values, validation errors, computed fields, etc.</li> </ol> <pre><code># models.py\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass Server(BaseModel):\n    host: str\n    port: int = 8080 # Pydantic default\n    protocol: str = Field(default=\"http\")\n\n# config.yaml\nserver: !Server # Use the Server model\n  host: \"api.example.com\"\n  # port is omitted, Pydantic default 8080 will be used\n  protocol: \"https\" # Overrides Pydantic default\n\n# main.py\nfrom dracon import DraconLoader\nfrom models import Server\n\nloader = DraconLoader(context={'Server': Server})\nconfig = loader.load('config.yaml')\n\nassert isinstance(config.server, Server)\nassert config.server.host == \"api.example.com\"\nassert config.server.port == 8080 # Default used\nassert config.server.protocol == \"https\" # Value from YAML used\n</code></pre>"},{"location":"types/#custom-types-non-pydantic","title":"Custom Types (Non-Pydantic)","text":"<p>You can use tags for your own non-Pydantic classes too.</p> <ul> <li> <p>Loading (<code>!MyClass</code>):</p> </li> <li> <p>Make the class available via the <code>context</code>.</p> </li> <li>Dracon will construct the node's data (e.g., into a <code>dict</code>).</li> <li>It will then attempt to call <code>MyClass(constructed_data)</code>.</li> <li> <p>Your class's <code>__init__</code> method must be able to handle the input type (e.g., accept a dictionary for mapping nodes).</p> </li> <li> <p>Dumping (Serialization):</p> </li> <li>By default, Dracon uses <code>ruamel.yaml</code>'s standard representation.</li> <li>To customize serialization, implement a <code>dracon_dump_to_node(self, representer)</code> method in your class. This method should return the desired <code>ruamel.yaml</code> node representation (e.g., <code>representer.represent_mapping('!MyClass', {'attr': self.attr})</code>).</li> </ul> <pre><code># custom_types.py\nclass Point:\n    # yaml_tag = '!Point' # Optional: For auto-registration later if needed\n\n    def __init__(self, data): # __init__ handles dict input\n        self.x = data.get('x', 0)\n        self.y = data.get('y', 0)\n\n    def __repr__(self):\n        return f\"Point(x={self.x}, y={self.y})\"\n\n    # Optional: Custom serialization hook\n    def dracon_dump_to_node(self, representer):\n        # Represent as a !Point mapping\n        return representer.represent_mapping(\n            '!Point', {'x': self.x, 'y': self.y}\n        )\n\n# config.yaml\nstart_point: !Point\n  x: 10\n  y: 20\n\n# main.py\nfrom dracon import DraconLoader\nfrom custom_types import Point\n\nloader = DraconLoader(context={'Point': Point})\nconfig = loader.load('config.yaml')\n\nassert isinstance(config.start_point, Point)\nassert config.start_point.x == 10\n\n# Dumping will use dracon_dump_to_node if available\nprint(loader.dump({'p': config.start_point}))\n# Output:\n# p: !Point\n#   x: 10\n#   y: 20\n</code></pre>"},{"location":"types/#dynamic-tags","title":"Dynamic Tags (<code>!$(...)</code>)","text":"<p>You can use immediate interpolation to dynamically determine the tag applied to a node based on context available at parse time.</p> <pre><code>!define shape_type: ${'Circle' if radius &gt; 0 else 'Point'}\n\n# The tag (!Circle or !Point) is determined when this is parsed\nmy_shape: !$(shape_type) # Fields relevant to Circle or Point...\n  radius: ${radius} # Assuming radius is in context\n  x: 0\n  y: 0\n</code></pre>"}]}